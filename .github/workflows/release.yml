name: Publish xrpl-py 🐍 distribution 📦 to PyPI
on:
  workflow_dispatch:
  push:


jobs:
  input-validate:
    name: Validate release inputs
    runs-on: ubuntu-latest
    outputs:
      package_version: ${{ steps.package_version.outputs.version }}
      is_beta_release: ${{ steps.detect_release_kind.outputs.is_beta_release }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Validate inputs
        run: |
          set -euo pipefail
          RELEASE_BRANCH="$(git branch --show-current || true)"
          if [[ -z "$RELEASE_BRANCH" ]]; then
            RELEASE_BRANCH="${{ github.ref_name }}"
          fi

          if [[ -z "$RELEASE_BRANCH" ]]; then
            echo "❌ Unable to determine branch name." >&2
            exit 1
          fi

          if [[ ! "${RELEASE_BRANCH,,}" =~ ^release[-/] ]]; then
            echo "❌ Release branch '$RELEASE_BRANCH' must start with 'release-' or 'release/'." >&2
            exit 1
          fi

          if grep -R --exclude-dir=.git --exclude-dir=.github "artifactory.ops.ripple.com" .; then
            echo "❌ Internal Artifactory URL found"
            exit 1
          else
            echo "✅ No Internal Artifactory URL found"
          fi

      - name: Install toml-cli
        run: |
          set -euo pipefail
          python3 -m venv /tmp/tomlcli
          /tmp/tomlcli/bin/pip install --upgrade pip
          /tmp/tomlcli/bin/pip install toml-cli
          echo "/tmp/tomlcli/bin" >> "${GITHUB_PATH}"

      - name: Extract package version
        id: package_version
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          rm -f /tmp/toml_err
          if ! VERSION="$(toml get project.version --toml-path pyproject.toml 2>/tmp/toml_err)"; then
            cat /tmp/toml_err >&2 || true
            echo "Unable to retrieve version from pyproject.toml using toml-cli" >&2
            exit 1
          fi
          rm -f /tmp/toml_err
          if [[ -z "${VERSION}" ]]; then
            echo "Version value is empty in pyproject.toml" >&2
            exit 1
          fi
          # Ensure no existing remote git tag matches this version (protect against re-releases)
          if gh api -X GET "repos/$REPO/git/ref/tags/${VERSION}" >/dev/null 2>&1 || \
             gh api -X GET "repos/$REPO/git/ref/tags/v${VERSION}" >/dev/null 2>&1; then
            echo "❌ A remote git tag matching the version already exists: '${VERSION}' or 'v${VERSION}'." >&2
            echo "Please bump the version in pyproject.toml or remove the existing git tag before releasing." >&2
            exit 1
          fi
          echo "version=${VERSION}" >> "${GITHUB_OUTPUT}"
          echo "Detected package version: ${VERSION}"

      - name: Detect release kind
        id: detect_release_kind
        run: |
          set -euo pipefail
          VERSION="${{ steps.package_version.outputs.version }}"
          if [[ "$VERSION" =~ (a|b|rc) ]]; then
            echo "is_beta_release=true" >> "$GITHUB_OUTPUT"
          else
            echo "is_beta_release=false" >> "$GITHUB_OUTPUT"
          fi

  faucet-tests:
    name: Run faucet tests matrix
    needs:
      - input-validate
    uses: ./.github/workflows/faucet_test.yml
    secrets: inherit

  integration-tests:
    name: Run integration tests matrix
    needs:
      - input-validate
    uses: ./.github/workflows/integration_test.yml
    secrets: inherit

  pre-release:
    name: Pre-release distribution 📦
    needs:
      - input-validate
      - faucet-tests
      - integration-tests
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
      attestations: write
      issues: write
    env:
      POETRY_VERSION: 2.1.1
      PACKAGE_VERSION: ${{ needs.input-validate.outputs.package_version }}
    outputs:
      package_version: ${{ needs.input-validate.outputs.package_version }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          # Use the lowest supported version of Python for CI/CD
          python-version: "3.9"
      - name: Load cached .local
        id: cache-poetry
        uses: actions/cache@v3
        with:
          path: /home/runner/.local
          key: dotlocal-${{ env.POETRY_VERSION }}-${{ hashFiles('poetry.lock') }}
      - name: Install poetry
        env:
          PIP_INDEX_URL: https://pypi.org/simple
          PIP_NO_CACHE_DIR: "1"
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install "dulwich>=0.22.6,<0.23.0"
          python -m pip install "https://github.com/python-poetry/poetry/releases/download/${POETRY_VERSION}/poetry-${POETRY_VERSION}-py3-none-any.whl"
          poetry --version
      - name: Build a binary wheel and a source tarball
        run: poetry build
      - name: Store the distribution packages
        uses: actions/upload-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
      - name: Generate build provenance attestation
        id: provenance
        uses: actions/attest-build-provenance@v1
        with:
          subject-path: "dist/*"
      - name: Store provenance attestation
        if: steps.provenance.outputs.bundle-path != ''
        uses: actions/upload-artifact@v4
        with:
          name: python-package-provenance
          path: ${{ steps.provenance.outputs.bundle-path }}
      - name: Install CycloneDX Python tool
        run: |
          set -euo pipefail
          python -m pip install --upgrade cyclonedx-bom
      - name: Generate CycloneDX SBOM
        run: |
          set -euo pipefail
          cyclonedx-py poetry > sbom.json
          if [[ ! -s sbom.json ]]; then
            echo "Generated SBOM is empty" >&2
            exit 1
          fi
      - name: Scan SBOM for vulnerabilities using Trivy
        uses: aquasecurity/trivy-action@0.28.0
        with:
          scan-type: sbom
          scan-ref: sbom.json
          format: table
          exit-code: 0
          output: vuln-report.txt
          severity: CRITICAL,HIGH
      - name: Upload sbom to OWASP
        run: |
          set -euo pipefail
          curl -X POST \
            -H "X-Api-Key: ${{ secrets.OWASP_TOKEN }}" \
            -F "project=576d4400-bc73-4dcb-93bc-313cf2652595" \
            -F "bom=@sbom.json" \
            https://owasp-dt-api.prod.ripplex.io/api/v1/bom
      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom
          path: sbom.json
      - name: Show scan report
        id: show_scan_report
        run: |
          set -euo pipefail
          if ! grep -qE "CRITICAL|HIGH" vuln-report.txt; then
            printf '\n%s\n' "✅ No CRITICAL or HIGH vulnerabilities detected for xrpl-py." >> vuln-report.txt
            echo "found_vulnerability=false" >> "$GITHUB_OUTPUT"
          else
            echo "found_vulnerability=true" >> "$GITHUB_OUTPUT"
          fi
          cat vuln-report.txt
      - name: Upload vulnerability report artifact
        id: upload_vuln
        uses: actions/upload-artifact@v4
        with:
          name: vulnerability-report
          path: vuln-report.txt
      - name: Build vuln artifact URL
        id: vuln_art
        run: |
          set -euo pipefail
          echo "art_url=https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}/artifacts/${{ steps.upload_vuln.outputs.artifact-id }}" >> "$GITHUB_OUTPUT"
      - name: Create GitHub Issue for vulnerabilities
        if: steps.show_scan_report.outputs.found_vulnerability == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          PKG_VER: ${{ env.PACKAGE_VERSION }}
          REL_BRANCH: ${{ github.ref_name }}
          VULN_ART_URL: ${{ steps.vuln_art.outputs.art_url }}
          LABELS: security
        run: |
          set -euo pipefail
          TITLE="🔒 Security vulnerabilities in xrpl-py@${PKG_VER}"
          : > issue_body.md
          {
            echo "The vulnerability scan has detected **CRITICAL/HIGH** vulnerabilities for \`xrpl-py@${PKG_VER}\` on branch \`${REL_BRANCH}\`."
            echo ""
            echo "**Release Branch:** \`${REL_BRANCH}\`"
            echo "**Package Version:** \`${PKG_VER}\`"
            echo ""
            echo "**Full vulnerability report:** ${VULN_ART_URL}"
            echo ""
            echo "Please review the report and take necessary action."
            echo ""
            echo "---"
            echo "_This issue was automatically generated by the Publish to PyPI workflow._"
          } >> issue_body.md
          gh issue create --title "$TITLE" --body-file issue_body.md --label "$LABELS"
  ask_for_dev_team_review:
    name: Summarize release and request Dev review
    runs-on: ubuntu-latest
    needs:
      - input-validate
      - faucet-tests
      - integration-tests
      - pre-release
    permissions:
      pull-requests: write
    env:
      PACKAGE_VERSION: ${{ needs.input-validate.outputs.package_version }}
      IS_BETA_RELEASE: ${{ needs.input-validate.outputs.is_beta_release }}
      RELEASE_BRANCH: ${{ github.ref_name }}
      SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ensure PR from release branch to main
        id: ensure_pr
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RELEASE_BRANCH: ${{ github.ref_name }}
          VERSION: ${{ env.PACKAGE_VERSION }}
        run: |
          set -euo pipefail
          if [[ "${IS_BETA_RELEASE}" == "true" ]]; then
            echo "Beta release detected → skipping PR creation for ${RELEASE_BRANCH}"
            exit 0
          fi
          OWNER="${REPO%%/*}"

          echo "🔎 Checking for existing PR from ${RELEASE_BRANCH} → main"
          PRS_JSON="$(gh api -H 'Accept: application/vnd.github+json' \
            "/repos/$REPO/pulls?state=open&base=main&head=${OWNER}:${RELEASE_BRANCH}")"

          PR_NUMBER="$(printf '%s' "$PRS_JSON" | jq -r '.[0].number // empty')"
          PR_URL="$(printf '%s' "$PRS_JSON" | jq -r '.[0].html_url // empty')"

          if [ -z "$PR_NUMBER" ]; then
            echo "📝 Creating release PR"
            CREATE_JSON="$(jq -n \
              --arg title "Release $VERSION: ${RELEASE_BRANCH} → main" \
              --arg head  "$RELEASE_BRANCH" \
              --arg base  "main" \
              --arg body  "Automated PR for release **$VERSION** from **$RELEASE_BRANCH** → **main**. Workflow Run: https://github.com/$REPO/actions/runs/${{ github.run_id }}" \
              '{title:$title, head:$head, base:$base, body:$body}')"

            RESP="$(gh api -H 'Accept: application/vnd.github+json' \
              --method POST /repos/$REPO/pulls --input <(printf '%s' "$CREATE_JSON"))"

            PR_NUMBER="$(printf '%s' "$RESP" | jq -r '.number')"
            PR_URL="$(printf '%s' "$RESP" | jq -r '.html_url')"
          else
            echo "ℹ️ Found existing PR #$PR_NUMBER"
          fi

          echo "pr_url=$PR_URL" >> "$GITHUB_OUTPUT"
          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"

      - name: Release summary for review
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          RUN_ID: ${{ github.run_id }}
          PACKAGE_VERSION: ${{ env.PACKAGE_VERSION }}
          RELEASE_BRANCH: ${{ env.RELEASE_BRANCH }}
          PR_URL: ${{ steps.ensure_pr.outputs.pr_url }}
        run: |
          set -euo pipefail
          ARTIFACT_NAME="vulnerability-report"
          ARTIFACTS=$(curl -s -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/artifacts")

          ARTIFACT_ID=$(echo "$ARTIFACTS" | jq -r ".artifacts[]? | select(.name == \"$ARTIFACT_NAME\") | .id")

          echo "📦 Package version: $PACKAGE_VERSION"
          echo "🌿 Release branch:  $RELEASE_BRANCH"
          if [[ "${IS_BETA_RELEASE}" != "true" && -n "${PR_URL:-}" ]]; then
            echo "🔀 Release PR:      $PR_URL"
          fi
          if [ -n "${ARTIFACT_ID:-}" ]; then
            echo "🛡️ Vulnerability report: https://github.com/$REPO/actions/runs/$RUN_ID/artifacts/$ARTIFACT_ID"
          else
            echo "⚠️ Vulnerability report artifact not found"
          fi

      - name: Notify dev reviewers on Slack
        env:
          REPO: ${{ github.repository }}
          PACKAGE_VERSION: ${{ env.PACKAGE_VERSION }}
          RELEASE_BRANCH: ${{ env.RELEASE_BRANCH }}
          PR_URL: ${{ steps.ensure_pr.outputs.pr_url }}
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
        run: |
          set -euo pipefail
          MSG="${{ github.actor }} prepared xrpl-py ${PACKAGE_VERSION} from ${RELEASE_BRANCH}. Please review the release artifacts (${RUN_URL})"
          if [[ "${IS_BETA_RELEASE}" != "true" && -n "${PR_URL:-}" ]]; then
            MSG="$MSG and review the release PR (${PR_URL})"
          fi
          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "$(jq -n --arg channel "#test-alert" --arg text "$MSG" '{channel:$channel, text:$text}')" \
            | jq -er '.ok' >/dev/null

  first_review:
    name: First approval (dev team)
    runs-on: ubuntu-latest
    needs:
      - input-validate
      - faucet-tests
      - integration-tests
      - pre-release
      - ask_for_dev_team_review
    environment:
      name: first-review
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    steps:
      - name: Awaiting approval
        run: echo "Awaiting Dev team approval"

  ask_for_sec_team_review:
    name: Request security team review
    runs-on: ubuntu-latest
    needs:
      - input-validate
      - faucet-tests
      - integration-tests
      - pre-release
      - ask_for_dev_team_review
      - first_review
    env:
      PACKAGE_VERSION: ${{ needs.input-validate.outputs.package_version }}
      SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
    steps:
      - name: Notify security reviewers on Slack
        env:
          RUN_URL: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
          PACKAGE_VERSION: ${{ env.PACKAGE_VERSION }}
        run: |
          set -euo pipefail
          MSG="${{ github.actor }} prepared xrpl-py ${PACKAGE_VERSION}. Security review needed for release artifacts (${RUN_URL})."
          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "$(jq -n --arg channel "#test-alert" --arg text "$MSG" '{channel:$channel, text:$text}')" \
            | jq -er '.ok' >/dev/null

      - name: Awaiting security approval
        run: echo "Waiting for security team review"

  publish-to-pypi:
    name: >-
      Publish Python 🐍 distribution 📦 to PyPI
    needs:
      - pre-release
      - ask_for_dev_team_review
      - first_review
      - ask_for_sec_team_review
    runs-on: ubuntu-latest
    timeout-minutes: 10 # Adjust based on typical publishing time
    environment:
      name: official-release
      url: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
    env:
      PACKAGE_VERSION: ${{ needs.pre-release.outputs.package_version }}
    permissions:
      # More information about Trusted Publishing and OpenID Connect: https://blog.pypi.org/posts/2023-04-20-introducing-trusted-publishers/
      id-token: write # IMPORTANT: mandatory for trusted publishing
    steps:
      - name: Download all the dists
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
      - name: Verify downloaded artifacts
        run: |
          ls dist/*.whl dist/*.tar.gz || exit 1
      - name: Publish distribution 📦 to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          verbose: true
          verify-metadata: true
          attestations: true

  github-release:
    name: Github Release
    needs:
      - pre-release
      - ask_for_dev_team_review
      - first_review
      - ask_for_sec_team_review
      - publish-to-pypi
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Adjust based on typical signing and release time

    permissions:
      contents: write # IMPORTANT: mandatory for making GitHub Releases
      id-token: write # IMPORTANT: mandatory for sigstore
    env:
      PACKAGE_VERSION: ${{ needs.pre-release.outputs.package_version }}

    steps:
      - name: Download all the dists
        uses: actions/download-artifact@v4
        with:
          name: python-package-distributions
          path: dist/
      - name: Download provenance attestations
        uses: actions/download-artifact@v4
        with:
          name: python-package-provenance
          path: provenance/
      - name: Sign the dists with Sigstore
        uses: sigstore/gh-action-sigstore-python@v3.0.1
        with:
          inputs: >-
            ./dist/*.tar.gz
            ./dist/*.whl
      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ github.token }}
        run: >-
          gh release create
          '${{ github.ref_name }}'
          --repo '${{ github.repository }}'
          --generate-notes ||
          (echo "::error::Failed to create release" && exit 1)
      - name: Upload artifact signatures to GitHub Release
        env:
          GITHUB_TOKEN: ${{ github.token }}
          # Upload to GitHub Release using the `gh` CLI.
          # `dist/` contains the built packages, and the
          # sigstore-produced signatures and certificates.
        run: >-
          gh release upload
          '${{ github.ref_name }}'
          dist/**
          provenance/**
          --repo '${{ github.repository }}'
          
      - name: Notify Slack success (single-line)
        if: success()
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
          REPO:        ${{ github.repository }}
          PACKAGE_NAME: ${{ env.PACKAGE_NAME }}
          PACKAGE_VERSION: ${{ env.PACKAGE_VERSION }}
          TAG:         ${{ steps.create_tag.outputs.tag_name }}
        run: |
          set -euo pipefail

          # Build release URL from tag (URL-encoded to handle '@' etc.)
          enc_tag="$(printf '%s' "$TAG" | jq -sRr @uri)"
          RELEASE_URL="https://github.com/$REPO/releases/tag/$enc_tag"

          text="${PACKAGE_NAME} ${PACKAGE_VERSION} has been succesfully released and published to npm.js. Release URL: ${RELEASE_URL}"
          text="${text//\\n/ }"

          curl -sS -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json; charset=utf-8" \
            -d "$(jq -n --arg channel "#xrpl-js" --arg text "$text" '{channel:$channel, text:$text}')"

      - name: Notify Slack if tests fail
        if: failure()
        env:
          SLACK_TOKEN: ${{ secrets.SLACK_TOKEN }}
        run: |
          MESSAGE="❌ Release failed for ${{ env.PACKAGE_NAME }}@${{ env.PACKAGE_VERSION }}. Check the logs: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          curl -X POST https://slack.com/api/chat.postMessage \
            -H "Authorization: Bearer $SLACK_TOKEN" \
            -H "Content-Type: application/json" \
            -d "$(jq -n \
                  --arg channel "#xrpl-js" \
                  --arg text "$MESSAGE" \
                  '{channel: $channel, text: $text}')"
